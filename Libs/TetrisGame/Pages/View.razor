@page "/tetris"
@inject IGameLoop GameLoop
@implements IDisposable
@using System.Globalization

<h3>Jeu Tetris</h3>

Remplacer "MonAppBlazor" par le nom réel de votre projet

<div class="tetris-layout">

    <div class="margin-column left-margin" style="@LeftMarginStyle">
        @* Vide *@
    </div>

    <div class="info-column">
        <div class="score-zone">
            <span>Meilleur Score:</span>
            <span class="score-value">@_bestScore</span>
        </div>
        <div class="controls-zone">
            <button class="start-button" @onclick="StartGame" disabled="@_isGameRunning">
                @(_isGameRunning ? "En Cours..." : "Démarrer")
            </button>
        </div>
        <div class="preview-zone">
            <span>Suivant:</span>
            <div class="preview-box">
                <div class="tetrimino-preview">
                    @if (previewShape != null)
                    {
                        @for (int row = 0; row < previewShape.GetLength(0); row++)
                        {
                            <div class="preview-row">
                                @for (int col = 0; col < previewShape.GetLength(1); col++)
                                {
                                    var cellValue = previewShape[row, col];
                                    var cssClass = "preview-cell " + (cellValue > 0 ? "filled type-" + cellValue : "empty");
                                    <div class="@cssClass"></div>
                                }
                            </div>
                        }
                    }
                </div>
                @* La prévisualisation du tétromino ira ici *@
            </div>
        </div>
    </div>

    <div class="spacer-column" style="@SpacerStyle">
        @* Vide *@
    </div>

    <div class="game-area-column">
        <div class="game-board-container">
            <div class="game-board" style="@GridBackgroundStyle">
                @* Affichage de la grille figée (optionnel pour l'instant) *@
                @* Vous pourriez boucler sur gameBoardGrid ici plus tard *@

                @* Affichage de la pièce qui tombe *@
                @if (hasActivePiece && currentPieceDefinition != null)
                {
                    int pieceRows = currentPieceDefinition.GetLength(1);
                    int pieceCols = currentPieceDefinition.GetLength(2);
                    // Récupérer la taille de cellule calculée en C#
                    var cellWidth = BoardWidthPx / GridColumns;
                    var cellHeight = BoardHeightPx / GridRows;

                    @for (int r = 0; r < pieceRows; r++)
                    {
                        @for (int c = 0; c < pieceCols; c++)
                        {
                            // Obtenir la valeur de la cellule pour la rotation actuelle
                            var cellValue = currentPieceDefinition[currentRotation, r, c];
                            if (cellValue > 0) // Afficher seulement les blocs pleins
                            {
                                // Calculer la position absolue en pixels
                                var top = (currentY + r) * cellHeight;
                                var left = (currentX + c) * cellWidth;
                                // Créer le style pour positionner le bloc
                                var style = $"position: absolute; " + 
                                            $"top: {top.ToString("0.##", CultureInfo.InvariantCulture)}px; " + 
                                            $"left: {left.ToString("0.##", CultureInfo.InvariantCulture)}px; " +
                                            $"width: {cellWidth.ToString("0.##", CultureInfo.InvariantCulture)}px; " +
                                            $"height: {cellHeight.ToString("0.##", CultureInfo.InvariantCulture)}px;";
                                // Appliquer les classes CSS (similaire à preview)
                                var cssClass = "game-cell filled type-" + cellValue;
                                <div class="@cssClass" style="@style"></div>
                            }
                        }
                    }
                }
            </div>
        </div>
    </div>

</div>

@code {
    // --- Paramètres pour la boucle de jeu ---
    private double _timeSinceLastDrop = 0.0;
    private const double TimeBetweenDrops = 0.8; // <- Temps spécifique à Tetris !

    private double _timeSinceLastInputCheck = 0.0;
    private const double InputCheckInterval = 0.05; // Vérifier input plus souvent

    // --- Paramètres des Tetriminos ---
    private Tetriminos tetriminosGenerator = new Tetriminos();
    private UInt16[,] previewShape; // Tableau 2D pour la prévisualisation

    // --- État du Plateau de Jeu ---
    private ushort[,] gameBoardGrid; // La grille où les pièces sont figées

    // --- État de la Pièce Actuelle ---
    private bool hasActivePiece = false; // Y a-t-il une pièce en train de tomber ?
    private ushort[,,] currentPieceDefinition; // Données 3D de la forme de la pièce actuelle
    private int currentRotation; // Index de la rotation actuelle (0, 1, 2...)
    private int currentX; // Colonne (0-9) de la pièce (point de référence, ex: coin sup gauche)
    private int currentY; // Ligne (0-19) de la pièce (point de référence)

    // --- Paramètres pour la grille ---
    [Parameter] public int GridColumns { get; set; } = 10;
    [Parameter] public int GridRows { get; set; } = 20;

    // --- Paramètres pour les largeurs variables ---
    [Parameter] public string LeftMarginWidth { get; set; } = "50px"; // Largeur de la marge gauche
    [Parameter] public string SpacerWidth { get; set; } = "30px"; // Largeur de l'espaceur

    // --- Dimensions fixes de la zone de jeu en pixels ---
    private const double BoardWidthPx = 304.0;
    private const double BoardHeightPx = 604.0;

    // --- Variables d'état du jeu ---
    private int _bestScore = 0; // Sera chargé/sauvé plus tard
    private int _currentScore = 0; // Score actuel (pas encore affiché, mais prêt)
    private bool _isGameRunning = false; // Pour l'état du bouton Start

    // --- Calcul pour le style de la grille en arrière-plan ---
    private string CellWidthString => (BoardWidthPx / GridColumns).ToString("0.##", CultureInfo.InvariantCulture) + "px";
    private string CellHeightString => (BoardHeightPx / GridRows).ToString("0.##", CultureInfo.InvariantCulture) + "px";
    private string GridBackgroundStyle => $"--cell-width: {CellWidthString}; --cell-height: {CellHeightString};";

    // --- Calcul pour les styles des colonnes variables ---
    private string LeftMarginStyle => $"width: {LeftMarginWidth};";
    private string SpacerStyle => $"width: {SpacerWidth};";


    // --- Méthode pour gérer la logique de jeu ---
    protected override async Task OnInitializedAsync()
    {
        // Appel de la méthode de base pour l'initialisation
        await base.OnInitializedAsync();

        // S'abonner à la boucle de jeu centrale
        GameLoop.TickOccurred += HandleGameTick;
        // S'assurer que le service a démarré la boucle JS (si ce n'est pas déjà fait)
        await GameLoop.EnsureLoopStartedAsync();

        InitializeBoard(); // Initialiser le tableau de jeu
        ShowPreview(); // Afficher la prévisualisation de la pièce
    }

    private void ShowPreview()
    {
        tetriminosGenerator = new Tetriminos();
        var randomPieceData3D = tetriminosGenerator.GetRandomTetriminos();

        // Extraire la première rotation (slice [0,*,*]) dans previewShape
        // Note: Ceci suppose que toutes les pièces ont au moins une rotation définie
        int rows = randomPieceData3D.GetLength(1);
        int cols = randomPieceData3D.GetLength(2);
        
        previewShape = new ushort[rows, cols]; // Initialiser le tableau 2D previewShape
        Console.WriteLine($"Preview Shape: {rows}x{cols}"); // Debug
        for (int r = 0; r < rows; r++)
        {
            for (int c = 0; c < cols; c++)
            {
                // Copier la tranche de la première rotation (index 0)
                previewShape[r, c] = randomPieceData3D[0, r, c]; 
            }
        }
    }

    private void InitializeBoard() 
    {
        gameBoardGrid = new ushort[GridRows, GridColumns];
        // Le tableau est initialisé à 0 par défaut, c'est parfait (vide).
        Console.WriteLine("Board Initialized.");
    }
    // --- Démarage du jeu ---
    private void StartGame()
    {
        if (!_isGameRunning)
        {
            Console.WriteLine("Démarrage du jeu !"); // Logique de démarrage à implémenter
            InitializeBoard(); // Réinitialiser le plateau
            _isGameRunning = true;
            _currentScore = 0;
            _timeSinceLastDrop = 0; // Réinitialiser le timer de chute
            _timeSinceLastInputCheck = 0;
            // Réinitialiser le plateau, générer la première pièce, etc.
            StateHasChanged(); // Notifie Blazor que l'état a changé (pour le bouton)
        }
    }

    // --- Méthode de gestion des ticks de la boucle de jeu ---
    private void HandleGameTick(double deltaTime)
    {
        if (!_isGameRunning) return; // Ne rien faire si le jeu n'est pas démarré
        
        
        // --- Logique de Timing Spécifique à Tetris ---

        // 1. Gestion de la descente de la pièce
        // 1. Logique de descente de la pièce
        if (hasActivePiece) // Seulement si une pièce est active
        {
            _timeSinceLastDrop += deltaTime;
            if (_timeSinceLastDrop >= TimeBetweenDrops)
            {
                _timeSinceLastDrop -= TimeBetweenDrops; 
                
                int nextY = currentY + 1;

                // --- DÉBUT SECTION À AJOUTER / MODIFIER ---
                // TODO: Vérifier la collision ici avant de déplacer !
                // bool collision = CheckCollision(currentX, nextY, currentRotation); 
                bool collision = false; // POUR L'INSTANT : on suppose PAS de collision

                if (collision)
                {
                    // La pièce devrait se verrouiller
                    // LockPiece(); // Méthode à créer
                    // SpawnNewPiece(); // Faire apparaître la suivante
                    Console.WriteLine($"Collision detected at Y={nextY}"); // Debug
                    // Pour l'instant, on arrête juste la pièce pour voir
                    // hasActivePiece = false; 
                }
                else
                {
                    // Déplacer la pièce vers le bas
                    currentY = nextY; 
                    // Console.WriteLine($"Piece moved down to Y={currentY}"); // Debug
                }
                // --- FIN SECTION À AJOUTER / MODIFIER ---
            }
        }

        // 2. Gestion des entrées utilisateur (plus fréquente)
        _timeSinceLastInputCheck += deltaTime;
        if (_timeSinceLastInputCheck >= InputCheckInterval)
        {
            _timeSinceLastInputCheck -= InputCheckInterval;
            // ---> VERIFIER LES INPUTS (gauche, droite, rotation) <---
            // Mettre à jour l'état si nécessaire
            // Console.WriteLine("Tetris Tick: Check input");
            // Potentiellement StateHasChanged() ici aussi si l'input change l'état visuel
        }

        // 3. Autres logiques à exécuter à chaque frame (ex: animations fluides)
        // ... ici ...
        
        StateHasChanged(); // Demander un re-rendu si l'état a changé
    }

    // Très important: Se désabonner lors de la destruction du composant
    public void Dispose()
    {
        GameLoop.TickOccurred -= HandleGameTick;
        Console.WriteLine("TetrisComponent: Disposed and unsubscribed from GameLoop.");
        // Note: On ne demande PAS au service d'arrêter la boucle ici.
        // Le service pourrait être utilisé par d'autres jeux/composants.
        // L'arrêt devrait être géré par le cycle de vie du service ou une logique applicative globale.
        // Ou, si on implémente le comptage d'abonnés dans le service, il s'arrêtera tout seul.
    }
}
